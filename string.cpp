/*
899. 有序队列
给出了一个由小写字母组成的字符串 S。然后，我们可以进行任意次数的移动。
在每次移动中，我们选择前 K 个字母中的一个（从左侧开始），将其从原位置移除，并放置在字符串的末尾。
返回我们在任意次数的移动之后可以拥有的按字典顺序排列的最小字符串。

示例 1：
输入：S = "cba", K = 1
输出："acb"
解释：
在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。
在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。
示例 2：
输入：S = "baaca", K = 3
输出："aaabc"
解释：
在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。
在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。
 
提示：
1 <= K <= S.length <= 1000
S 只由小写字母组成。
*/

/*
思路： K==1的情况下可以看成字符串首尾连接，从len种切割方式中选择最小的那个为最终结果；
K>1的情况下可以看成相邻的K个字母间的顺序是可以交换的，因为前K个字符中可以任意选择一个字符加入到末尾，所以前K个字符的顺序是可以变化的
由于不限定移动的次数，所以当K>1时直接将字符串S中的字符进行从小到大排序就可以了
*/

class Solution {
public:
    string orderlyQueue(string S, int K) {
        string tmps=S;
        if(K==1){
            int len=S.size();
            for(int i=0;i<len;i++){
                S=S.substr(1,len-1)+S[0];
                if(S<tmps)
                    tmps=S;
            }
        }
        else{
            sort(tmps.begin(),tmps.end());
        }
        return tmps;
    }
};
